For our solution, we used two classes, one for the generic player called Player, stored in the player.py module, and one for the board called Board, stored in the board.py module. Each player will have a Board object to determine the state of the board currently, which will be equally updated for each players' moves through self-updating through its own moves or through the update function for the enemy moves. Another module called strategies.py stores the functions needed to determine what the optimal move to make is, and another module called constants.py stores all the magic numbers used in the code.

In terms of searching for the best action to take, we decided to use the Minimax strategy, as Watch Your Back is a deterministic and perfect-information game, thus we can assume a perfect playing enemy in which Minimax will search for us the best move. Our Minimax algorithm will have a depth of 2 layers as this is the best choice that allows the greatest depth within the space and time constraints.

The minimax strategy implemented uses an evaluation function that was calculated through looking at the desirability of how surrounded and safe each piece on the board was. For each piece, we calculate its vulnerability, and subtract that from its max vulnerability to get its level of defense. A piece's vulnerability is calculated as a 1:3:4 weighted sum of the number of axes a piece can be eliminated, the average level of danger a piece is from opponent elimination (0 for not surrounded, 0.5 for 1 adjacent enemy piece, and 1 for surrounded), and the level of danger a piece is from the board shrinking (0 to 1, slowly rising throughout the phase for edge pieces). The evaluation function's score is the sum of all the player's pieces' level of defense minus the enemy's pieces' level of defense.

We also tried to optimize the minimax strategy with the help of a-b pruning, which can help eliminate many branches in the minimax search. Although minimax can be visualized as a tree, we did not use any tree data structure, instead recursing through it as a depth-first search.

The evaluation function was discovered through playing the game in real life with other students taking the subject to discover certain strategies and how desirable some positions may be. We decided to look at each piece individually and rate it based upon its neighbours and how close it is to being eliminated, with the weight being calculated through trial and error to give an appropriate ranking for each of the possible piece-neighbour combinations, of which there are 7-8.