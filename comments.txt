For our solution, we used two classes, one for the generic player called Player, stored in the player.py module, and one for the different states of the game/board called Gamestate, stored in the gamestate.py module. Each player will have a Gamestate object to determine the state of the board currently, which will be equally updated for each players' moves through self-updating through its own moves or through the update function for the enemy moves.

In terms of searching for the best action to take, we decided to use the Minimax strategy, as Watch Your Back is a deterministic and perfect-information game, thus we can assume a perfect playing enemy in which Minimax will search for us the best move. Our Minimax algorithm will have a depth of ? layers as this is the best choice that allows the greatest depth within the space and time constraints.

The minimax strategy implemented uses an evaluation function that was calculated through looking at the desirability of how surrounded and safe each piece on the board was. For each piece, we calculate its vulnerability, and subtract that from its max vulnerability to get its level of defense. A piece's vulnerability is calculated as a 1:3 weighted sum of the number of axes a piece can be eliminated, and the average level of danger a piece is in (0 for not surrounded, 0.5 for 1 adjacent enemy piece, and 1 for surrounded). The evaluation function's score is the sum of all the player's pieces' level of defense minus the enemy's pieces' level of defense.

We also tried to optimize the minimax strategy with the help of a-b pruning, 
	